# üó∫Ô∏è SQL & Spatial Cheat Sheet

> **A quick, visual reference for spatial SQL best practices.**  
> _Shareable, updateable, and consistent across projects!_

---

<div align="center">
    <img src="https://upload.wikimedia.org/wikipedia/commons/8/83/Equirectangular_projection_SW.jpg" alt="Spatial Data" width="400"/>
</div>

---

## üõ†Ô∏è Housekeeping

### üóÇÔ∏è Spatial Data Types & Conventions

| **SRID**      | **Name**         | **Usage**                         | **Example**                        |
|:-------------:|:----------------|:----------------------------------|:-----------------------------------|
| **4326**      | WGS84 (Lat/Lon) | üåç Storage & analysis (default)   | `geometry(Polygon, 4326)`            |
| **3857**      | Web Mercator    | üó∫Ô∏è Map visualisation only         | `geometry(Polygon, 3857)`         |

> **üí° Tip:**  
> Store spatial data as **geometry (EPSG:4326)** unless you _really_ need geography for speed (e.g. MAPP queries).

---

#### üß≠ Geography vs Geometry

|                | **Geometry**                                 | **Geography**                                  |
|----------------|----------------------------------------------|------------------------------------------------|
| üìè Plane       | Flat Cartesian plane                         | Curved surface (spheroid)                      |
| ‚ö° Speed       | Fast for local analysis                      | Slower, but accurate for global calculations   |
| üìê Accuracy    | Can be inaccurate for long distances         | Best for distance/area across large extents    |

---

#### üè∑Ô∏è Naming Conventions

- `geom_p_4326` ‚Üí **Point** geometries in EPSG:4326  
- `geom_4326` ‚Üí **Polygon/MultiPolygon** geometries in EPSG:4326

---

### ‚úÖ DO's and ‚ùå DON'Ts

| ‚úÖ **DO** | ‚ùå **DON'T** | ‚ùî **WHY** |
|---|---|---|
| Use `GENERATED BY DEFAULT AS IDENTITY` for PKs | Use `SERIAL` for PKs | `SERIAL` creates a sequence with extra dependencies and permissions. |
| Use `snake_case` for names | Use capitals, spaces, or start with numbers | Consistency, readability, and avoids quoting. |
| Use explicit `JOIN` syntax | Use comma notation for joins | Prevents accidental cross joins. |
| Use `UNION ALL` by default | Use `UNION` unless deduplication is needed | `UNION` deduplicates and is slower. |
| Use CTEs for multiple joins | Join lots of tables directly | CTEs improve readability and prevent duplication. |
| Use `EPSG:4326 (geography)` for distances | Calculate distances in EPSG:3857 | Geography is built for metres. |
| `SELECT COUNT(column)` | `SELECT COUNT(*)` | `COUNT(column)` skips nulls; `COUNT(*)` counts all rows. |
| Use `varchar(n)` or `text` for strings | Use `char(n)` for strings | `char(n)` pads with spaces, causing comparison issues. |
| Guard against division by zero | Ignore division by zero | Use `NULLIF` to prevent errors. |
| Use `INTEGER` for division | Use `FLOAT/NUMERIC` for division | Integer division truncates, not rounds. |
| Filter joined tables in `ON` clause (LEFT JOIN) | Filter in `WHERE` clause (LEFT JOIN) | Filtering in `ON` preserves NULLs from the left table. |

---

#### ‚ö†Ô∏è LEFT JOIN Filtering Example

<div style="display: flex; gap: 2em;">
<div>

**Good:**
```sql
SELECT a.id, b.id
FROM table_a a
LEFT JOIN table_b b
    ON a.id = b.a_id AND b.some_condition = 'value';
```
</div>
<div>

**Bad:**
```sql
SELECT a.id, b.id
FROM table_a a
LEFT JOIN table_b b
    ON a.id = b.a_id
WHERE b.some_condition = 'value';
```
</div>
</div>

---

## üóÉÔ∏è Indexes & Primary Keys

### üîë Primary Keys

- Every table **must** have a primary key (`id`).
- Ensures uniqueness & reliable joins.
- Use `GENERATED BY DEFAULT AS IDENTITY` for auto-incrementing IDs.

```sql
ALTER TABLE my_table
ADD CONSTRAINT my_table_pkey PRIMARY KEY (id);

CREATE TABLE my_table (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
);
```

---

### üß≠ Spatial Indexes

- Use **GiST indexes** for spatial columns for fast queries.
- Index both `geometry` and `geography` types, including transformations and casts.

```sql
CREATE INDEX sidx_my_table_geom_p_4326 ON my_table USING GIST (geom_p_4326);
CREATE INDEX sidx_my_table_geog_p_4326 ON my_table USING GIST (geog_p_4326);
CREATE INDEX sidx_my_table_geom_p_4326_geog ON my_table USING GIST ((geom_p_4326::geography));
CREATE INDEX sidx_my_table_geom_p_4326_3857 ON my_table USING GIST (ST_Transform(geom_p_4326, 3857));
```

---

## üöÄ Common SQL Patterns & Functions

### üîó Spatial Joins & Analysis

| Function | Purpose | Example |
|---|---|---|
| `ST_Intersects` | Find intersecting geometries (e.g. point-in-polygon) | `ON ST_Intersects(a.geom, b.geom)` |
| `ST_DWithin` | Find points within a buffer (distance, must use geography) | `ON ST_DWithin(a.geom::geography, b.geom::geography, 1000)` |
| `ST_Intersection` | Get the overlapping geometry between two features | `ST_Intersection(a.geom, b.geom)` |
| `ST_Buffer` | Create buffer around geometry (third param for smoothness) | `ST_Buffer(geom, 1000, 64)` |

**Examples:**

```sql
-- Intersecting geometries
SELECT a.id, b.id
FROM table_a a
JOIN table_b b
    ON ST_Intersects(a.geom_p_4326, b.geom_4326);

-- Within buffer (1000 meters)
SELECT a.id, b.id
FROM table_a a
JOIN table_b b
    ON ST_DWithin(a.geom_p_4326::geography, b.geom_4326::geography, 1000);

-- Intersection geometry
SELECT a.id, b.id, ST_Intersection(a.geom_p_4326, b.geom_p_4326) AS intersection_geom
FROM table_a a
JOIN table_b b
    ON ST_Intersects(a.geom_p_4326, b.geom_p_4326);

-- Buffer with smooth edges
SELECT ST_Buffer(geom, 1000, 64) AS buffered_geom
FROM table_name;
```

---

### üü¶ Nearest Neighbor Search

Find the closest feature using `CROSS JOIN LATERAL` and `<->` operator:

```sql
SELECT a.id, nearest.id, 
       ST_Distance(a.geom_p_4326::geography, nearest.geom_4326::geography) AS distance_metres
FROM table_a a
CROSS JOIN LATERAL (
    SELECT b.id
    FROM table_b b
    ORDER BY a.geom_p_4326::geography <-> b.geom_4326::geography
    LIMIT 1
) nearest;
```

---

### üü™ Multi-Band Aggregation with `CROSS JOIN UNNEST`

Aggregate metrics across multiple drivetime or buffer bands efficiently:

```sql
SELECT band.band || ' Min Drivetime' AS band,
       SUM(oa.population_current) AS pop
FROM my_table s
CROSS JOIN UNNEST(ARRAY [5,10,15,20]) band
LEFT JOIN geodata.uk_glx_geodata_oa_metrics_2021 oa
    ON ST_Intersects(
        CASE
            WHEN band.band = 5 THEN s.isoline_5min
            WHEN band.band = 10 THEN s.isoline_10min
            WHEN band.band = 15 THEN s.isoline_15min
            WHEN band.band = 20 THEN s.isoline_20min
        END,
        oa.geom_p_4326
    )
WHERE s.${qID} = %{id}
GROUP BY s.id, band.band
ORDER BY band.band;
```

**With `ST_DWithin`:**

```sql
SELECT band.band AS buffer_metres,
       SUM(oa.population_current) AS pop
FROM my_table s
CROSS JOIN UNNEST(ARRAY [1000, 2000, 3000]) band
LEFT JOIN geodata.uk_glx_geodata_oa_metrics_2021 oa
    ON ST_DWithin(s.geom_p_4326::geography, oa.geom_4326::geography, band.band)
WHERE s.${qID} = %{id}
GROUP BY s.id, band.band
ORDER BY band.band;
```

> **Tip:**  
> `CROSS JOIN UNNEST` lets you aggregate for multiple bands in a single, fast query‚Äîno repetitive code.

---

## ü™ü Window Functions

Window functions perform calculations **across related rows** without collapsing them. Useful for ranking, running totals, and analytics.

### üîπ Syntax & Examples

```sql
SELECT 
    column1,
    SUM(column2) OVER (PARTITION BY column3 ORDER BY column4) AS running_total
FROM table_name;
```

| Function | Description |
|---|---|
| `ROW_NUMBER()` | Unique sequential number per partition |
| `RANK()` | Same values share rank, gaps appear |
| `DENSE_RANK()` | Same values share rank, no gaps |
| `PERCENT_RANK()` | Normalized rank between 0 and 1 |

**Ranking Example:**

```sql
SELECT
    id,
    value,
    ROW_NUMBER() OVER(PARTITION BY category ORDER BY value DESC) AS row_num,
    RANK() OVER(PARTITION BY category ORDER BY value DESC) AS rank,
    DENSE_RANK() OVER(PARTITION BY category ORDER BY value DESC) AS dense_rank,
    PERCENT_RANK() OVER(PARTITION BY category ORDER BY value DESC) AS percent_rank
FROM sales;
```

**Running Totals & Moving Averages:**

```sql
SELECT
    id,
    value,
    SUM(value) OVER (PARTITION BY category ORDER BY date ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS running_total,
    AVG(value) OVER (PARTITION BY category ORDER BY date ROWS BETWEEN 4 PRECEDING AND CURRENT ROW) AS moving_avg_5
FROM sales;
```

**Top N per Group (with CTE):**

```sql
WITH ranked_sales AS (
    SELECT
        id,
        category,
        value,
        RANK() OVER (PARTITION BY category ORDER BY value DESC) AS rank
    FROM sales
)
SELECT *
FROM ranked_sales
WHERE rank <= 5;
```

---

## üß∞ Essential SQL Functions

### String Functions

| Function | Purpose | Example |
|---|---|---|
| `INITCAP` | Capitalize first letter of each word | `SELECT INITCAP(column_name)` |
| `TRIM` | Remove leading/trailing spaces | `SELECT TRIM(column_name)` |
| `REGEXP_REPLACE` | Replace patterns using regex, this replaces non-alphanumeric characters (globally in the column because of the _'g'_) | `SELECT REGEXP_REPLACE(store_name, '[^a-zA-Z0-9 ]', '', 'g')` |
| <code>\|\|</code> | Concatenate strings | <code>SELECT address \|\| ', ' \|\| city</code> |

### Numeric & Logical Functions

| Function | Purpose | Example |
|---|---|---|
| `ROUND` | Round to decimal places | `SELECT ROUND(column_name, 2)` |
| `<>` | Not equal to | `SELECT * FROM table WHERE col <> 'value'` |

### Aggregation & Array Functions

| Function | Purpose | Example |
|---|---|---|
| `ARRAY_AGG` | Aggregate values into array | `SELECT category, ARRAY_AGG(value) FROM sales GROUP BY category` |
| `COALESCE` | Default value if null | `SELECT COALESCE(store_type, 'standard')` |

### JSON Functions

| Function | Purpose | Example |
|---|---|---|
| `JSON_BUILD_OBJECT` | Create JSON object | `SELECT JSON_BUILD_OBJECT('key1', value1)` |
| `->`, `->>`, `#>`, `#>>` | Extract JSON values | `SELECT json_data ->> 'store_name'` |

---

> **Keep this sheet handy for quick reference and best practices in spatial SQL!**
